#include "../../Include.jsx";CSGlobal.setDebugLevel(1);var APPLICATION_ROOT = '/Users/calhoun/Work/Screens-circuitboard';var SMOBS_ROOT = APPLICATION_ROOT + '/smobs-yellow';var FINETUNE_ORIGINAL = APPLICATION_ROOT + '/sequence-test';try{  var g = new Geometry();    var docRefOrg = app.open(new File(FINETUNE_ORIGINAL+'.psd'));  var docRefCompare = app.open(new File(FINETUNE_ORIGINAL+'-compare.psd'));  app.activeDocument = docRefOrg;    // Make sure number of layers in both docs is equal?    for (var j = 0; j < docRefOrg.artLayers.length; j++)    {    // Check that layer names are the same? Make sure we are dealing with same smob...???        var fOrg = new Fragment();    fOrg.setFragmentDocument(docRefOrg);    fOrg.setFragmentLayer(fOrg.getFragmentDocument().artLayers[j]);    fOrg.loadBounds();    var fCompare = new Fragment();    fCompare.setFragmentDocument(docRefCompare);    fCompare.setFragmentLayer(fCompare.getFragmentDocument().artLayers[j]);    fCompare.loadBounds();        CSGlobal.csDebug(1, "\nOriginal: " + fOrg.getFragmentName());    CSGlobal.csDebug(1, "Compare: " + fCompare.getFragmentName());    /*var diffX = ((fCompare.getProperty('top').getX() - fOrg.getProperty('top').getX()));    var diffY = ((fCompare.getProperty('top').getY() - fOrg.getProperty('top').getY()));    CSGlobal.csDebug(1, "X difference: " + diffX);    CSGlobal.csDebug(1, "Y difference: " + diffY);*/    var fOrgCenterX = fOrg.getProperty('center').getX().value;    CSGlobal.csDebug(1, "fOrg center X: " + fOrgCenterX);    var fCompareCenterX = fCompare.getProperty('center').getX().value;    CSGlobal.csDebug(1, "fCompare center X: " + fCompareCenterX);    var fOrgCenterY = fOrg.getProperty('center').getY().value;    CSGlobal.csDebug(1, "fOrg center Y: " + fOrgCenterY);    var fCompareCenterY = fCompare.getProperty('center').getY().value;    CSGlobal.csDebug(1, "fCompare center Y: " + fCompareCenterY);    var fOrgWidth = fOrg.getWidth().value;    CSGlobal.csDebug(1, "fOrg width: " + fOrgWidth);    var fCompareWidth = fCompare.getWidth().value;    CSGlobal.csDebug(1, "fCompare width: " + fCompareWidth);        //var thetaOrg = Number(g.getPolarTheta(fOrg.getProperty('top')));    //var thetaCompare = Number(g.getPolarTheta(fCompare.getProperty('top')));    var diffX = (fCompareCenterX - fOrgCenterX);    var diffY = (fCompareCenterY - fOrgCenterY);    var diffA = (fCompareWidth - fOrgWidth);    CSGlobal.csDebug(1, "X difference: " + diffX);    CSGlobal.csDebug(1, "Y difference: " + diffY);    CSGlobal.csDebug(1, "A difference: " + diffA);    //CSGlobal.csDebug(1, "thetaOrg: " + thetaOrg);    //CSGlobal.csDebug(1, "thetaCompare: " + thetaCompare);    if (fOrgCenterX != fCompareCenterX)    {      CSGlobal.csDebug(1, fOrg.getFragmentName() + " was moved in X.");    }    if (fOrgCenterY != fCompareCenterY)    {      CSGlobal.csDebug(1, fOrg.getFragmentName() + " was moved in Y.");    }    /*if (fOrgWidth != fCompareWidth)    {      CSGlobal.csDebug(1, fOrg.getFragmentName() + " was rotated.");    }*/        if (diffX.value != 0 || diffY.value != 0)    //if (diffX != 0 || diffY != 0 || diffA != 0)    {      var tmp = new File(SMOBS_ROOT + '/' + fOrg.getFragmentName());      var tmpFileRef = app.open(tmp);      var f = new Fragment();      f.setFragmentDocument(tmpFileRef);      f.setKey(0);      f.setFragmentLayer(f.getFragmentDocument().artLayers[f.getKey()]);      var keywords = f.getKeywords();            /*      // Here begins the process of translating the fine-tuning done on a fragment.      // See larger paragraph below for hopefully some clarity about the pain in the ass this was...      var coordinate = new Coordinate(new Number(keywords.cx), new Number(keywords.cy));      CSGlobal.csDebug(2, "Coordinate: " + coordinate.getX() + ", " + coordinate.getY());        var r = g.getPolarR(coordinate);      CSGlobal.csDebug(2, "r: " + r);        var a = new Number(keywords.a);      CSGlobal.csDebug(2, "a: " + keywords.a);        var theta = g.getPolarTheta(coordinate);      CSGlobal.csDebug(2, "theta: " + theta);        var theta2 = new Number((theta - a));      CSGlobal.csDebug(2, "theta2: " + theta2);        // The idea was that we needed to calculate (again) the newCoord just like when we originally      // generated values for a, cx, and cy for smobs. At the moment a fragment (or smob) is fine-tuned, the O is      // the newCoord values, not the cx and cy values saved as info in each individual fragment's file metdata as keywords.      // Those values need to be changed of course for the fine-tuning to stick, but we have to work backwards      // from after the fact of the rotation, since the compare files are built from adjusting the fragments after      // rotation....does this make sense?      var newCoord = g.getCartesian(r, theta2);      CSGlobal.csDebug(2, "newCoord: " + newCoord.getX() + ", " + newCoord.getY());        // The negative one in the axis is because these movements are relative to the origin which is at the center of the fragment.      // Is this the same for the Y coordinate? Y in Ps is opposite of Cartesian Y.      var tunedCoord = new Coordinate(new Number((newCoord.getX() + (diffX * -1))), new Number((newCoord.getY() + diffY)));      CSGlobal.csDebug(2, "tunedCoord: " + tunedCoord.getX() + ", " + tunedCoord.getY());        var tunedR = g.getPolarR(tunedCoord);      CSGlobal.csDebug(2, "tunedR: " + tunedR);      var tunedTheta = g.getPolarTheta(tunedCoord);      CSGlobal.csDebug(2, "tunedTheta: " + tunedTheta);      var tunedTheta2 = new Number((tunedTheta + a));      CSGlobal.csDebug(2, "tunedTheta2: " + tunedTheta2);      var tunedNewCoord = g.getCartesian(tunedR, tunedTheta2);            CSGlobal.csDebug(2, "tunedNewCoord: " + tunedNewCoord.getX() + ", " + tunedNewCoord.getY());            // Here is where we set new cx, cy values in smob based on x,y adjustments in fine-tuning compare file,      // which are calculated as somewhat describe above.      keywords.cx = tunedNewCoord.getX();      CSGlobal.csDebug(1, "new cx value: " + keywords.cx);      keywords.cy = tunedNewCoord.getY();      CSGlobal.csDebug(1, "new cy value: " + keywords.cy);            //keywords.a = tunedTheta2;      //CSGlobal.csDebug(1, "new a value: " + keywords.a);      */            keywords.cx = Number(Number(keywords.cx)) + Number(Number(diffX*-1));      keywords.cy = Number(Number(keywords.cy)) + Number(Number(diffY));      //keywords.a = Number(Number(keywords.a) + (Number(Number(thetaCompare) - Number(thetaOrg))));      //CSGlobal.csDebug(1, "Keywords length: " + keywords.length);      f.setKeywords(keywords);      f.getFragmentDocument().save();      f.getFragmentDocument().close();    }  }}catch (e){  CSGlobal.csDebug(1,e.message);}CSGlobal.setEnableNotifiers(false);